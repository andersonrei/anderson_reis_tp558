# -*- coding: utf-8 -*-
"""PAPR_DQN_CORRECT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D-1bTwxyRhPprO4bCJOk9QLhJ6Da8knE
"""

import numpy as np
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import tensorflow as tf
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.models import clone_model
from tensorflow.keras.optimizers import Adam
from collections import deque
import random
import matplotlib.pyplot as plt
import sionna as sn
import time
from stable_baselines3 import DQN
from stable_baselines3.common.monitor import Monitor
from stable_baselines3.common.evaluation import evaluate_policy
import numpy as np
import gymnasium as gym
from gymnasium import spaces
import itertools
from itertools import product
from stable_baselines3.common.vec_env import DummyVecEnv
from stable_baselines3 import DQN
from sklearn.model_selection import train_test_split

import os
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"   # permite que o programa continue
os.environ["OMP_NUM_THREADS"] = "1"           # limita threads OpenMP
os.environ["MKL_NUM_THREADS"] = "1"

#%% Environment:

#symbols_min_arr = np.load('C:/Users/bianc/OneDrive - Instituto Nacional de Telecomunicações/MESTRADO/Mestrado_Atualizado/Python_code/OFDM/PAPR Reduction/symbols_min_arr.npy')

#symbols_train, symbols_test = train_test_split(symbols_min_arr, test_size=0.3, random_state=42)

#eixo_x_w_Pil = np.load('C:/Users/bianc/OneDrive - Instituto Nacional de Telecomunicações/MESTRADO/Mestrado_Atualizado/Python_code/OFDM/PAPR Reduction/eixo_x_w_Pil.npy')
#ccdf_w_Pil = np.load('C:/Users/bianc/OneDrive - Instituto Nacional de Telecomunicações/MESTRADO/Mestrado_Atualizado/Python_code/OFDM/PAPR Reduction/ccdf_w_Pil.npy')

#pilotos = np.sqrt(0.5) * (np.random.randn(100, 2) + 1j * np.random.randn(100, 2))

# Normalizar cada piloto para ter energia unitária (opcional, se quiser amplitude = 1)
#pilotos = pilotos / np.abs(pilotos)

class DQNEnvironment(gym.Env):
    def __init__(self, N_data=14, N_total=16, N_symbols_fixos=50000, seed=None):
        super().__init__()
        self.N_data = N_data
        self.N_total = N_total
        self.N_symbols_fixos = N_symbols_fixos
        #self.symbols_train = symbols_train
        self.M = 4  # Ordem QAM
        self.N_pilots = 2
        self.E = 1
        self.NUM_BITS_PER_SYMBOL = int(np.log2(self.M))
        self.BLOCK_LENGTH = (self.N_total - self.N_pilots) * self.NUM_BITS_PER_SYMBOL
        self.cont = 0

        # Inicializa fonte binária, constelação e mapper
        self.binary_source = sn.utils.BinarySource()
        self.constellation = sn.mapping.Constellation("qam", self.NUM_BITS_PER_SYMBOL, normalize=True)
        self.mapper = sn.mapping.Mapper(constellation=self.constellation)
        self.demapper = sn.mapping.Demapper("app", constellation=self.constellation, hard_out=True)
        self.awgn_channel = sn.channel.AWGN()
        
        self.bits_total = np.array([
                self.binary_source([1, self.BLOCK_LENGTH]) for _ in range(self.N_symbols_fixos)
            ])
            
            # Map each bit sequence to a symbol
        self.symbols_fixos = np.squeeze(np.array([
            self.mapper(bits) for bits in self.bits_total
        ], dtype=np.complex64))

        
        #self.symbols_train, self.symbols_test = train_test_split(self.symbols_fixos, test_size=0.3, shuffle=False)
        
        self.current_index = 0

        # Pilotos determinísticos: todas combinações possíveis de N_pilots a partir de valores_base
        # valores base para QPSK (±1/√2)
        self.valores_base = np.array([0.70710677, -0.70710677], dtype=np.float32)
        #self.valores_base = np.array([0.31622777, -0.31622777, 0.9486833, -0.9486833], dtype=np.float32)
        #self.valores_base = np.linspace(0, 4*np.pi, 5, endpoint=False)
        # primeiro: gerar os 4 símbolos QPSK possíveis (combinando real x imag)

        qpsk_symbols = [complex(r, i) for (r, i) in product(self.valores_base, repeat=2)]
         #qpsk_symbols tem 4 elementos: [+0.707+0.707j, +0.707-0.707j, -0.707+0.707j, -0.707-0.707j]

        # agora: todas as combinações possíveis de (Pilot1, Pilot2) -> 4 x 4 = 16
        pilotos_possiveis = list(product(qpsk_symbols, repeat=self.N_pilots))

        # converter para array (forma: [16, 2]) onde cada linha é [pilot1, pilot2]
        self.Pilots = np.array(pilotos_possiveis, dtype=np.complex64)
        # atualizar o action_space para ter 16 ações
        self.action_space = spaces.Discrete(len(pilotos_possiveis))

        # Observação: vetor concatenado real/imag do símbolo
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(2*(self.N_total - self.N_pilots),), dtype=np.float32)

        # Histórico
        self.symbols_min = np.zeros((self.symbols_fixos.shape[0], N_total), dtype=complex)
        self.symbols_ori = np.zeros((self.symbols_fixos.shape[0], N_total), dtype=complex)
        self.tx_signal_total_Pil = np.zeros((self.symbols_fixos.shape[0], N_total), dtype=complex)
        self.papr_total_Pil = np.zeros((self.symbols_fixos.shape[0],))
        self.tx_signal_total_NoPil = np.zeros((self.symbols_fixos.shape[0], N_total), dtype=complex)
        self.papr_total_NoPil = np.zeros((self.symbols_fixos.shape[0],))

    # -----------------------------
    # Funções de transmissão
    # -----------------------------
    
    def transmitir_sem_pilotos(self, symbol):
        frame = np.zeros((self.N_total,), dtype=complex)
        frame[1:1+self.N_data] = symbol
        frame[0] = 0.0
        frame[-1] = 0.0
        tx_signal_no_pil = np.fft.ifft(frame, n=self.N_total) * np.sqrt(self.N_total)
        papr_no_pil = self.calcular_papr(tx_signal_no_pil)
        return frame, tx_signal_no_pil, papr_no_pil

    def transmitir_com_pilotos(self, Pil, symbol):
        frame = np.zeros((self.N_total,), dtype=complex)
        frame[1:1+self.N_data] = symbol
        frame[0] = Pil[0]   # primeiro piloto
        frame[-1] = Pil[1]  # segundo piloto
        tx_signal_pil = np.fft.ifft(frame, n=self.N_total) * np.sqrt(self.N_total)
        papr_with = self.calcular_papr(tx_signal_pil)
        return frame, tx_signal_pil, papr_with
    '''
    def transmitir_sem_pilotos(self, symbol):
        frame = np.zeros((self.N_total,), dtype=complex)
        idx_central = self.N_total // 2  # posição central (DC)
    
        # Divide os dados em duas partes (antes e depois da DC)
        n_before = self.N_data // 2
        n_after = self.N_data - n_before  # cobre casos de N_data ímpar
    
        # Preenche antes e depois da DC
        frame[1:1+n_before] = symbol[:n_before]
        frame[idx_central+1:idx_central+1+n_after] = symbol[n_before:]
    
        # Zeros nas bordas e no centro
        frame[0] = 0.0
        frame[idx_central] = 0.0
        frame[-1] = 0.0
    
        tx_signal_no_pil = np.fft.ifft(frame, n=self.N_total) * np.sqrt(self.N_total)
        papr_no_pil = self.calcular_papr(tx_signal_no_pil)
        return frame, tx_signal_no_pil, papr_no_pil


    def transmitir_com_pilotos(self, Pil, symbol):
        frame = np.zeros((self.N_total,), dtype=complex)
        idx_central = self.N_total // 2
    
        # Divide os dados em duas partes (antes e depois da DC)
        n_before = self.N_data // 2
        n_after = self.N_data - n_before  # cobre casos ímpares
    
        # Preenche antes e depois da DC
        frame[1:1+n_before] = symbol[:n_before]
        frame[idx_central+1:idx_central+1+n_after] = symbol[n_before:]
    
        # Insere pilotos e zeros
        frame[0] = Pil[0]
        frame[-1] = Pil[1]
        frame[idx_central] = 0.0  # zero na subportadora DC
    
        tx_signal_pil = np.fft.ifft(frame, n=self.N_total) * np.sqrt(self.N_total)
        papr_with = self.calcular_papr(tx_signal_pil)
        return frame, tx_signal_pil, papr_with
    '''

    # -----------------------------
    # Cálculo PAPR
    # -----------------------------
    def calcular_papr(self, signal):
        potencia = np.abs(signal)**2
        papr = 10 * np.log10(np.max(potencia)/np.mean(potencia))
        return papr

    # -----------------------------
    # Reset
    # -----------------------------
    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.current_index = 0
        self.cont = 0

        self.symbol = self.symbols_fixos[self.current_index]
        symbols_ori_, tx_signal_no_pil, papr_no_pil = self.transmitir_sem_pilotos(self.symbol)

        observation = np.concatenate([np.real(self.symbol), np.imag(self.symbol)], axis=-1).astype(np.float32)
        info = {"papr_no_pil": float(papr_no_pil)}
        return observation, info

    # -----------------------------
    # Step
    # -----------------------------
    def step(self, action):
        Pil = self.Pilots[action]
        #print(Pil)
        # Transmitir
        symbols_min_, tx_signal_pil, papr_pil = self.transmitir_com_pilotos(Pil, self.symbol)
        symbols_ori_, tx_signal_no_pil, papr_no_pil = self.transmitir_sem_pilotos(self.symbol)

        # Armazenar histórico
        self.symbols_ori[self.current_index] = symbols_ori_
        self.tx_signal_total_NoPil[self.current_index] = tx_signal_no_pil
        self.papr_total_NoPil[self.current_index] = papr_no_pil
        
        if papr_pil <= self.papr_total_Pil[self.current_index]:
          self.symbols_min[self.current_index] = symbols_min_
          self.tx_signal_total_Pil[self.current_index] = tx_signal_pil
          self.papr_total_Pil[self.current_index] = papr_pil
          reward = 1
        else:
          self.symbols_min[self.current_index] = symbols_min_
          self.tx_signal_total_Pil[self.current_index] = tx_signal_pil
          self.papr_total_Pil[self.current_index] = papr_pil
          reward = -1

        # Próximo símbolo
        self.current_index += 1
        self.cont += 1
        done = self.current_index >= self.symbols_fixos.shape[0]
        truncated = False
        
        if not done:
            self.symbol = self.symbols_fixos[self.current_index]
            observation = np.concatenate([np.real(self.symbol), np.imag(self.symbol)], axis=-1).astype(np.float32)
        else:
            observation = np.zeros((2*(self.N_total - self.N_pilots),), dtype=np.float32)
        #print(reward)
        info = {"papr_pil": float(papr_pil), "papr_no_pil": float(papr_no_pil)}
        return observation, reward, done, truncated, info

    # -----------------------------
    # Render e close
    # -----------------------------
    def render(self):
        pass

    def close(self):
        pass


#%%
import torch
'''
from torch import nn

env = DummyVecEnv([lambda: DQNEnvironment(N_data=62, N_total=64, N_symbols_fixos=100000)])
#model = DQN("MlpPolicy", env, verbose=1)
#policy_kwargs = dict(net_arch=[256, 256])  # "net_arch" define o número de neurônios em cada camada oculta da rede MLP
policy_kwargs = dict(
    net_arch=[256, 256],
    activation_fn=nn.Sigmoid,
)

model = DQN(
    "MlpPolicy",
    env,
    learning_rate=3.3962882274491235e-05,
    buffer_size=1_000_000,
    learning_starts=10_000,
    batch_size=64,
    tau=1.0,
    gamma=0.9253276888839851,
    train_freq=1,
    target_update_interval=100,
    policy_kwargs=policy_kwargs,
    verbose=1,
    exploration_initial_eps=1.0,  # valor inicial (default)
    exploration_final_eps=0.05,   # valor final (default)
    exploration_fraction=0.8,     # fração do total de timesteps para decair de 1 -> 0.05
    device="cuda"
)
'''
env = DummyVecEnv([lambda: DQNEnvironment(N_data=14, N_total=16, N_symbols_fixos=50000)])
#model = DQN("MlpPolicy", env, verbose=1)
policy_kwargs = dict(
    net_arch=[256]
)

model = DQN(
    "MlpPolicy",
    env,
    learning_rate=5e-4,
    buffer_size=200_000,
    learning_starts=2000,
    batch_size=512,
    tau=1,
    gamma=0.99,
    train_freq=1,
    target_update_interval=100,
    policy_kwargs=policy_kwargs,
    verbose=1,
    exploration_initial_eps=1.0,
    exploration_final_eps=0.05,
    exploration_fraction=0.2,
    device="cuda"
)

model.exploration_rate = model.exploration_initial_eps

model.learn(total_timesteps=2000000)

#%% Teste:

def calcular_ccdf(PAPR_final):
    PAPR_Total_red = PAPR_final.size 
    mi = min(PAPR_final)
    ma = max(PAPR_final)
    eixo_x_red = np.arange(mi, ma, 0.4) 
    y_red = []
    for jj in eixo_x_red:
        A_red = len(np.where(PAPR_final > jj)[0])/PAPR_Total_red
        y_red.append(A_red)    
    CCDF_red = y_red
    return eixo_x_red, CCDF_red


def testar_dqn(env, Pilots, num_test=3000):

  # Testa o DQN em símbolos novos não vistos no treinamento.

    papr_test = []

    # 1. Gerar bits e símbolos novos
    bits_test = env.envs[0].binary_source([num_test, int(env.envs[0].BLOCK_LENGTH)])
    symbols_test_ = env.envs[0].mapper(bits_test)

    # 2. Iterar sobre cada símbolo de teste
    for i in range(num_test):
        print(i)
        symbol = symbols_test_[i]
        #symbol_ori_, tx_signal_no_pil, papr_no_pil = env.envs[0].transmitir_sem_pilotos(symbol)
        # Estado = desvio padrão do símbolo (real e imaginário)
        state = np.concatenate([np.real(symbol), np.imag(symbol)], axis=-1).astype(np.float32)
        # Ajusta shape para o modelo
        #state = np.expand_dims(state, axis=0)

        # Predição
        q_values = model.predict(state)
        #action = np.argmax(q_values[0])
        #print(action)
        # 4. Transmitir com pilotos escolhidos
        Pilots = env.envs[0].Pilots[q_values[0]]
        symbol_min_with, tx_signal_pil, papr_val = env.envs[0].transmitir_com_pilotos(Pilots, symbol)
        # 5. Calcular PAPR
        #papr_val = env.calcular_papr(tx_signal_pil)
        papr_test.append(papr_val)

        # Debug opcional
        # print(f"Símbolo {i}: Ação {action}, PAPR={papr_val:.2f} dB")

    # 6. Calcular CCDF
    print(np.array(papr_test))
    eixo_x1, ccdf1 = calcular_ccdf(np.array(papr_test))


    return eixo_x1, ccdf1

# Testar em símbolos novos
eixo_x1, ccdf1 = testar_dqn(env, env.envs[0].Pilots)

'''
tx_signal_total = np.zeros((env.num_symbols,env.N_total), dtype=complex)
bits_total = np.zeros((env.num_symbols,int(env.BLOCK_LENGTH)))
papr_total = np.zeros((env.num_symbols))
bits_total, tx_signal_total, papr_total = env.transmitir_sem_pilotos(env.num_symbols, papr_total)
'''
eixo_x_w_Pil, ccdf_w_Pil = calcular_ccdf(env.envs[0].papr_total_NoPil)
eixo_x, ccdf = calcular_ccdf(env.envs[0].papr_total_Pil)

#%% Plot:

plt.figure(figsize=(9,7))
plt.semilogy(eixo_x, ccdf, label='Trainning', linewidth=3.5)
plt.semilogy(eixo_x1, ccdf1, label='Test', linewidth=3.5, linestyle='--')
plt.semilogy(eixo_x_w_Pil, ccdf_w_Pil, label='Original', linewidth=3.5, linestyle=':')
plt.xlabel("PAPR [dB]", fontsize=16, fontweight='bold')
plt.ylabel("CCDF", fontsize=16, fontweight='bold')
plt.grid(True, which='both', linestyle='--', linewidth=0.8, alpha=0.7)
plt.ylim(1e-3, 1)
plt.xlim(min(eixo_x_w_Pil), max(eixo_x_w_Pil))
plt.legend(fontsize=16, loc='upper right', frameon=True)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.tight_layout()
plt.show()

#%% #----------------------------------BER-------------------------------------------------#
import math
from scipy import special

def receptor(tx_signal, bits_transmitidos, EbN0_dB, modo):
    EbN0 = 10**(EbN0_dB / 10)
    N0 = env.envs[0].E / (np.log2(env.envs[0].M) * EbN0)

    if modo == 'com_pilotos':
        N0 = N0 * (env.envs[0].N_total / (env.envs[0].N_total - env.envs[0].N_pilots))

    N0 = tf.cast(N0, tf.float32)

    # Conversão para numpy array
    tx_signal = np.array(tx_signal)
    bits_transmitidos = np.array(bits_transmitidos)

    # Canal AWGN
    rx_signal = env.envs[0].awgn_channel([tx_signal, N0])

    # FFT e normalização
    rx_symbols = np.fft.fft(rx_signal, n=env.envs[0].N_total, axis=1) / np.sqrt(env.envs[0].N_total)
    rx_symbols = rx_symbols.astype(np.complex64)
    # Seleciona apenas os dados (removendo pilotos)
    rx_symbols = rx_symbols[:, 1:1 + env.envs[0].N_data]
    
    # Demapeamento para bits
    rx_bits_binary = env.envs[0].demapper([rx_symbols, N0])
    rx_bits_binary = np.array(rx_bits_binary)

    # Debug: imprime os shapes
    print("bits_transmitidos.shape:", bits_transmitidos.shape)
    print("rx_bits_binary.shape:", rx_bits_binary.shape)

    # Verifica se os shapes são iguais
    if bits_transmitidos.shape != rx_bits_binary.shape:
        try:
            rx_bits_binary = rx_bits_binary.reshape(bits_transmitidos.shape)
        except:
            raise ValueError(f"Shapes incompatíveis: bits_transmitidos {bits_transmitidos.shape}, rx_bits_binary {rx_bits_binary.shape}")

    # BER
    ber = np.mean(bits_transmitidos != rx_bits_binary)

    return ber, bits_transmitidos, rx_bits_binary

#n_70_percent = math.ceil(0.7 * env.envs[0].symbols_fixos.shape[0])

#mapp = env.envs[0].symbols_fixos[-n_70_percent:]

bits_total = np.squeeze(env.envs[0].bits_total)

tx_signal_total = env.envs[0].tx_signal_total_NoPil
tx_signal_total_Pil = env.envs[0].tx_signal_total_Pil
   
EbN0_dB = np.arange(0, 11)
ber_sem_pilotos = []
ber_com_pilotos = []

num_iter = 30  # Número de simulações por Eb/N0

for ebn0 in EbN0_dB:
    ber1_total = 0
    ber2_total = 0
    for _ in range(num_iter):
        ber1, bits_transmitidos1, rx_bits1 = receptor(tx_signal_total, bits_total, ebn0, modo='sem_pilotos')
        ber1_total += ber1
        
        ber2, bits_transmitidos2, rx_bits2 = receptor(tx_signal_total_Pil, bits_total, ebn0, modo='com_pilotos')
        ber2_total += ber2
        
        
    ber_sem_pilotos.append(ber1_total / num_iter)
    ber_com_pilotos.append(ber2_total / num_iter)
    
# BER teórica:
    
    
M = 2**(env.envs[0].NUM_BITS_PER_SYMBOL)
L = np.sqrt(M)
mu = 4 * (L - 1) / L  # Número médio de vizinhos
Es = 3 / (L ** 2 - 1) # Fator de ajuste da constelação
    
BER_THEO = np.zeros((len(EbN0_dB)))
BER_THEO_des = np.zeros((len(EbN0_dB)))

i = 0
for idx in EbN0_dB:
    BER_THEO_des[i] = (mu/(2*np.log2(M)))*special.erfc(np.sqrt(((env.envs[0].N_total-env.envs[0].N_pilots)/env.envs[0].N_total)*Es*
                                                               env.envs[0].NUM_BITS_PER_SYMBOL*10**(idx/10))/np.sqrt(2))
    BER_THEO[i] = (mu/(2*np.log2(M)))*special.erfc(np.sqrt(Es*env.envs[0].NUM_BITS_PER_SYMBOL*10**(idx/10))/np.sqrt(2))
    i = i+1

# Plota resultado
plt.semilogy(EbN0_dB, BER_THEO, '-', label='Original Theoretical')
plt.semilogy(EbN0_dB, BER_THEO_des, '--', label='Displaced theory')
plt.semilogy(EbN0_dB, ber_sem_pilotos, 'o', label='Simulation Original')
plt.semilogy(EbN0_dB, ber_com_pilotos, 's', label='Deep Q-Learning')
plt.xlabel('Eb/N0 (dB)')
plt.ylabel('BER')
plt.grid(True)
plt.ylim([1e-5, 1])
plt.legend()
plt.show()